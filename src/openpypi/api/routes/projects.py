"""
Projects API routes for OpenPypi.
Implementation for project management endpoints.
"""

from datetime import datetime  # Added import
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status

from openpypi.api.dependencies import get_api_key
from openpypi.api.schemas import APIResponse, ErrorResponse, ProjectListResponse, ProjectMetadata
from openpypi.utils.logger import get_logger

logger = get_logger(__name__)
router = APIRouter()

# Placeholder for project storage/database
# In a real application, this would interact with a database or a persistent file store.
_mock_projects_db: List[ProjectMetadata] = [
    ProjectMetadata(
        package_name="example_project_1",
        description="An example project generated by OpenPypi.",
        version="0.1.0",
        author="Test User",
        created_at=datetime.utcnow(),
        last_modified=datetime.utcnow(),
        project_path="/mnt/projects/example_project_1",  # Example server path
        status="generated",
    ),
    ProjectMetadata(
        package_name="another_cool_project",
        description="A very cool project about space llamas.",
        version="1.2.3",
        author="Dev Team",
        created_at=datetime.utcnow(),
        last_modified=datetime.utcnow(),
        project_path="/mnt/projects/another_cool_project",
        status="deployed",
    ),
]


@router.get(
    "",
    response_model=ProjectListResponse,
    summary="List Generated Projects",
    description="Retrieves a list of projects that have been generated or are managed by OpenPypi.",
)
async def list_projects(
    skip: int = Query(0, ge=0, description="Number of projects to skip (for pagination)."),
    limit: int = Query(
        10, ge=1, le=100, description="Maximum number of projects to return (for pagination)."
    ),
    status_filter: Optional[str] = Query(
        None,
        alias="status",
        description="Filter projects by status (e.g., 'generated', 'deployed').",
    ),
    api_key: str = Depends(get_api_key),
) -> ProjectListResponse:
    """Lists projects managed by OpenPypi, with optional filtering and pagination."""
    logger.info(f"Listing projects: skip={skip}, limit={limit}, status_filter='{status_filter}'")

    projects_to_return = _mock_projects_db
    if status_filter:
        projects_to_return = [p for p in projects_to_return if p.status == status_filter.lower()]

    paginated_projects = projects_to_return[skip : skip + limit]

    return ProjectListResponse(
        success=True,
        message=f"Retrieved {len(paginated_projects)} projects.",
        data=paginated_projects,
    )


@router.get(
    "/{package_name}",
    response_model=APIResponse,  # Should be ProjectMetadata or a wrapped response
    summary="Get Project Details",
    description="Retrieves detailed information about a specific generated project.",
    responses={404: {"model": ErrorResponse, "description": "Project not found"}},
)
async def get_project_details(
    package_name: str, api_key: str = Depends(get_api_key)
) -> APIResponse:
    """Retrieves metadata and status for a specific package name."""
    logger.info(f"Fetching details for project: {package_name}")
    project = next((p for p in _mock_projects_db if p.package_name == package_name), None)

    if not project:
        logger.warning(f"Project not found: {package_name}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Project with package name '{package_name}' not found.",
        )

    return APIResponse(success=True, data=project)


@router.delete(
    "/{package_name}",
    response_model=APIResponse,
    summary="Delete Project",
    description="Deletes a generated project and its associated files/metadata.",
    responses={
        404: {"model": ErrorResponse, "description": "Project not found"},
        501: {"model": ErrorResponse, "description": "Deletion not implemented"},
    },
)
async def delete_project(package_name: str, api_key: str = Depends(get_api_key)) -> APIResponse:
    """Deletes a project. Implementation: removes files and database entries."""
    logger.info(f"Attempting to delete project: {package_name}")
    # Placeholder - Deletion logic would go here (file system, database, etc.)
    # For now, we'll just check if it exists in our mock DB and simulate removal.
    project_index = -1
    for i, proj in enumerate(_mock_projects_db):
        if proj.package_name == package_name:
            project_index = i
            break

    if project_index == -1:
        logger.warning(f"Attempted to delete non-existent project: {package_name}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Project '{package_name}' not found for deletion.",
        )

    # Simulate deletion
    # del _mock_projects_db[project_index]
    # logger.info(f"Project '{package_name}' (mock) deleted.")
    # For now, returning Not Implemented as it's safer for a placeholder.
    logger.warning(f"Project deletion for '{package_name}' is not fully implemented.")
    raise HTTPException(
        status_code=status.HTTP_501_NOT_IMPLEMENTED,
        detail=f"Deletion of project '{package_name}' is not yet implemented.",
    )
    # return APIResponse(success=True, message=f"Project '{package_name}' scheduled for deletion.")

    # Implementation: Project deletion would handle file system and database cleanup

    # Implementation notes for future endpoints:
